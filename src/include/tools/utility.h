#pragma once

#include <SDL2/SDL.h>

#include <string>
#include <vector>

#include <tools/types.h>

/**
 * @brief Convert Degrees to Radians
 *
 * @param degrees The Input Degrees
 * @return The Output Radians
 */
float radians(float degrees)
{
    return degrees * M_RAD;
}

int clamp(int n, int min, int max)
{
    if (n < min)
        return min;
    if (n > max)
        return max;
    return n;
}

float clamp(float n, float min, float max)
{
    if (n < min)
        return min;
    if (n > max)
        return max;
    return n;
}

vec2 clamp(vec2 v, vec2 min, vec2 max)
{
    return {clamp(v.x, min.x, max.x), clamp(v.y, min.y, max.y)};
}

vec3 clamp(vec3 v, vec3 min, vec3 max)
{
    return {clamp(v.x, min.x, max.x), clamp(v.y, min.y, max.y), clamp(v.z, min.z, max.z)};
}

// -------- STRING --------

/**
 * @brief Slides the output linearly to the input
 *
 * @param x Input
 * @param in_min The minimal value of the input
 * @param in_max The maximal value of the input
 * @param out_min The minimal value of the output
 * @param out_max The maximal value of the output
 * @return Output
 */
float map(float x, float in_min, float in_max, float out_min, float out_max)
{
    return ((x - in_min) * (out_max - out_min)) / (in_max - in_min) + out_min;
}

/**
 * @brief Split apart a string by a d
 *
 * @param s The string to split
 * @param d The cut's position
 * @param part The part to select
 * @return One part of the original string
 */
std::string split(std::string s, std::string d, int part)
{
    size_t pos_start = 0, pos_end, delim_len = d.length();
    std::string token;
    std::vector<std::string> res;

    while ((pos_end = s.find(d, pos_start)) != std::string::npos)
    {
        token = s.substr(pos_start, pos_end - pos_start);
        pos_start = pos_end + delim_len;
        res.push_back(token);
    }

    res.push_back(s.substr(pos_start));
    return res[part];
}

/**
 * @brief Split apart a string by a d and convert it to Int
 *
 * @param s The string to split
 * @param d The cut's position
 * @param part The part to select
 * @return An integer generated by the split's output
 */
int isplit(std::string s, std::string d, int part)
{
    return stoi(split(s, d, part));
}

/**
 * @brief Split apart a string by a d and convert it to Float
 *
 * @param s The string to split
 * @param d The cut's position
 * @param part The part to select
 * @return A float generated by the split's output
 */
float fsplit(std::string s, std::string d, int part)
{
    return stof(split(s, d, part));
}

/**
 * @brief Count how many times does a character appear in a string
 *
 * @param s The string
 * @param d The character to count
 * @return The number of appearances
 */
int count(std::string s, char d)
{
    int c = 0;

    for (int i = 0; i < (int)s.size(); i++)
        if (s[i] == d)
            c++;

    return c;
}

/**
 * @brief Count how many times does a string appear in another string
 *
 * @param s The main string
 * @param d The string to count
 * @return The number of appearances
 */
int count(std::string s, std::string d)
{
    int c = 0;
    int size[2] = {(int)s.size(), (int)d.size()};

    if (size[0] < size[1])
        return 0;
    if (size[0] == size[1])
    {
        if (s == d)
            return 1;
        return 0;
    }

    for (int i = 0; i < size[0] - size[1]; i++)
    {
        int hits = 0;
        for (int a = 0; a < size[1]; a++)
        {
            if (s[i + a] == d[a])
                hits++;
        }

        if (hits == size[1])
            c++;
    }
    return c;
}

/**
 * @brief Check if a string appears in an other string
 *
 * @param s The main string
 * @param d The string to check
 * @return the result
 */
bool isin(std::string s, std::string d)
{
    int c = 0;
    int size[2] = {(int)s.size(), (int)d.size()};

    if (size[0] < size[1])
        return false;

    if (size[0] == size[1])
    {
        if (s == d)
            return true;
        return false;
    }

    for (int i = 0; i < size[0] - size[1]; i++)
    {
        int hits = 0;
        for (int a = 0; a < size[1]; a++)
        {
            if (s[i + a] == d[a])
                hits++;
        }

        if (hits == size[1])
            return true;
    }
    return false;
}

std::string lowercase(std::string s)
{
    int difference = 'a' - 'A';
    std::string ss = s;
    for (int i = 0; i < (int)s.size(); i++)
    {
        if (s[i] >= 'A' && s[i] <= 'Z')
        {
            ss[i] += difference;
        }
    }

    return ss;
}

std::string simplify(std::string s)
{
    std::string ss;
    int open = 0;

    for (int i = 0; i < (int)s.size(); i++)
    {
        if (s[i] == '(' || s[i] == '[' || s[i] == '<')
            open++;
        else if (s[i] == ')' || s[i] == ']' || s[i] == '>')
            open--;

        if ((s[i] >= 'A' && s[i] <= 'Z') || (s[i] >= 'a' && s[i] <= 'z') || (s[i] >= '0' && s[i] <= '9') || (s[i] == '.' || s[i] == ',' || s[i] == ' '))
            if (open == 0)
                ss += s[i];
    }
    return ss;
}

std::string despace(std::string s)
{
    std::string ss;
    for (int i = 0; i < (int)s.size(); i++)
    {
        if (s[i] != ' ' && s[i] != '\n' && s[i] != '\t' && s[i] != '\0')
            ss += s[i];
    }
    return ss;
}

/**
 * @brief Measure the size of a char*
 *
 * @param str The char* (aka string) to measure
 * @return The length of the char* (aka string)
 */
int strsize(const char *str)
{
    int c = 0;
    while (*str)
    {
        str++;
        c++;
    }
    return c;
}

/**
 * @brief Convert an integer to string
 *
 * @param num the integer
 * @return the generated string
 */
std::string itos(int num)
{
    return std::to_string(num);
}

/**
 * @brief Convert a float to string
 *
 * @param num the float
 * @return the generated string
 */
std::string ftos(float num)
{
    return std::to_string(num);
}

std::string ctos(char c)
{
    return std::string("") + c;
}

// ---------- Surface ----------
void flip_surface(SDL_Surface *surface)
{
    SDL_LockSurface(surface);

    int pitch = surface->pitch;   // row size
    char *temp = new char[pitch]; // intermediate buffer
    char *pixels = (char *)surface->pixels;

    for (int i = 0; i < surface->h / 2; ++i)
    {
        // get pointers to the two rows to swap
        char *row1 = pixels + i * pitch;
        char *row2 = pixels + (surface->h - i - 1) * pitch;

        // swap rows
        memcpy(temp, row1, pitch);
        memcpy(row1, row2, pitch);
        memcpy(row2, temp, pitch);
    }

    delete[] temp;

    SDL_UnlockSurface(surface);
}